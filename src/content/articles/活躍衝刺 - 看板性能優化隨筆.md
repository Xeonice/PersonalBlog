# 活躍沖刺 - 看板性能優化隨筆

# 開端

今年年初，組長要求在 Agile 看板中加入一個史詩泳道功能，其功能大致如下：

![史詩泳道](https://imagetemp.oss-cn-beijing.aliyuncs.com/2019-03-29-%E5%8F%B2%E8%AF%97%E6%B3%B3%E9%81%93.png?x-oss-process=style/TestCompress)

原先的代碼結構中根本沒有考慮過泳道之間互相嵌套的問題，而且原先的代碼大部分都是這個畫風：

![互相嵌套的代碼](https://imagetemp.oss-cn-beijing.aliyuncs.com/2019-03-29-162228.jpg?x-oss-process=style/TestCompress)

這種代碼幾乎是完全無法覆用的，而且多層 for 循環嵌套寫出的邏輯近乎於完全無法維護。因此，我決定向組長申請重構，徹底從根源上解決代碼整體結構問題

# 過程

在完全沒有開发文檔，代碼註釋，以及單元測試的項目中進行重構工作，是一件非常令人頭疼的問題。如果不熟悉原先的代碼，很容易會改出各種各樣的 bug，或者做少了功能。所以我在進行代碼重構前的第一步，就是整理整體代碼邏輯，書寫了一份簡單的思維導圖，用於整理原先的功能，避免重構過程中由於 bug 產生的多次返工。

![活躍沖刺-文檔](https://imagetemp.oss-cn-beijing.aliyuncs.com/2019-03-29-%E6%B4%BB%E8%B7%83%E5%86%B2%E5%88%BA--%E9%A1%B5%E9%9D%A2%E5%91%88%E7%8E%B0.png?x-oss-process=style/TestCompress)

> 實際開发流程中，這份思維導圖的功能應當被完備的單元測試所代替。書寫這麽一份簡單的思維導圖來統計功能也是因為原先沒有任何開发文檔留存所導致的。

之後的問題主要集中在看板拖拽功能上，這一部分在重構過程中近乎完全重寫

## 原先如何實現拖拽

![看板界面](https://imagetemp.oss-cn-beijing.aliyuncs.com/2019-03-29-%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202019-03-29%2012.04.34.png?x-oss-process=style/TestCompress)

原先的開发人員在實現拖拽功能的時候，**將每個列看成一個整體，存取數據時按照列存取，當拖拽操作发生時，只是將當前卡片由當前列移動至下一個列並變動排序，故事之間的關聯關系通過不斷遍歷數組去查詢。**

這種對拖拽的處理可以說是相當低效，如上圖，我在故事泳道中拖動一個故事 `Pannel` 下的子任務，更新數據時根本不應該讓其他的 `Pannel` 進行重新渲染。這種操作成本高昂，又沒有什麽實際意義。更重要的是，這種變動會讓之後維護的開发者不明所以，因為**後端要求返回的數據要求是極多的，既要狀態，也要故事/史詩關聯關系。**

![錯誤示範](https://imagetemp.oss-cn-beijing.aliyuncs.com/2019-03-29-%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202019-03-29%2012.17.22.png?x-oss-process=style/TestCompress)

如上圖所示，之前的開发者通過多個 For 循環遍歷數組，做了很多次 `O(n^3)` 的操作，只是為了獲取當前各種各樣的關聯關系，雖然客戶機普遍不存在性能瓶頸，但是多層 For 循環本身就是不易於維護的，更不用說這種不規範的 `len`、`len2` 命名導致的理解歧義了。

原先的代碼中，因為內部的處理邏輯是將列看作一個整體，所以我們每移動一張卡片都會導致兩個列完全重新渲染。如果客戶在`待處理`列放了 300 條 `issue`，而整個看板只有 302 條 `issue`，即使我們拖拽的目標列沒有 `issue`，也會導致 React 同時更新 300 條 `issue`。這種情況下，是否使用 React 與 Mobx 幾乎是沒有意義的。因為每次拖拽約等於更新了整個頁面，嚴重違背了 React 減少利用 `Virtul-DOM` 減少渲染次數的初衷。

## 如何對原先的代碼做改進？

分析原先的看板數據結構，可以发現後端返回給我們的數據已經包含了 `issue` 在看板中的各種關系，而且已經用嵌套對象形成了清晰的層級結構。結合後端返回的數據結構，我們可以輕松的構建出`列-狀態-issue` 的相關關系，`無泳道（不對 issue 進行分類）`情況下的整體數據呈現也隨之形成了。

![數據關系](https://imagetemp.oss-cn-beijing.aliyuncs.com/2019-03-29-%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202019-03-29%2016.08.32-1.png?x-oss-process=style/TestCompress)

但是僅僅憑後端查出的這套數據，是完全沒有辦法滿足前端通過 `故事`、`史詩`、`經辦人` 進行數據分類的需求的，所以我們需要結合後端傳回的其他數據對這些數據進行分類。

### 改善原先的數據結構

既然後端需要各種各樣的關聯關系，那麽我們完全可以提前存一張 `issueId` 與 `issue` 相關聯的 Map，在 `ComponentDidMount` 時提前將後端需要的各種關聯關系存進 `issue`，在拖拽結束通過 `issueId` 去查詢對應的 `issue` 直接拿對應的關聯關系。這樣做雖然在初始化數據時時間覆雜度依然為 `O(n^3)`，而且會比數組方法耗費內存，但是在獲取關聯關系時只需要 `O(1)` 的時間就能拿到對應的值，而且不必每次微小的操作都要執行 `O(n^3)` 覆雜度的運算。

![先構建一張總 Map](https://imagetemp.oss-cn-beijing.aliyuncs.com/2019-03-29-%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202019-03-29%2016.08.32.png?x-oss-process=style/TestCompress)

![再根據這張總 Map 結合後端返回的其他數據進行分類](https://imagetemp.oss-cn-beijing.aliyuncs.com/2019-03-29-%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202019-03-29%2016.50.27.png?x-oss-process=style/TestCompress)

這樣改進結構後，我們就可以按照 React 的設計哲學做到針對不同 `Pannel` 進行部分更新。如下圖所示，移動位於經辦人泳道下的 `issue` 時，我們只需要按照 `‘泳道模式-經辦人 Id/other（無經辦人問題）’ -> 狀態 Id` 查詢出需要操作的數組，並進行操作即可。

![先根據泳道，關聯 ID 生成一張 Map](https://imagetemp.oss-cn-beijing.aliyuncs.com/2019-03-29-%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202019-03-29%2017.00.15.png?x-oss-process=style/TestCompress)

![移動 issue 時，通過事先設定好的 swimlaneId（這里是經辦人模式，所以是 \`assignee-${assigneeId}\`）與 statusId 查詢對應的數組，移動這條 issue 即可](https://imagetemp.oss-cn-beijing.aliyuncs.com/2019-03-29-%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202019-03-29%2017.01.43.png?x-oss-process=style/TestCompress)

### 去除重覆 Render

之前的代碼中，一個函數調用的 `action` 過多，導致每執行一次 `action`，就會進行一次 `render`。這樣就直接導致首屏渲染時間過長，很多時候加載瓶頸都集中在刷新後的重覆渲染中。這與 `mobx` 設計初衷是背道而馳的。因此，這一部分的主要工作與之前的優化一樣，通過合並 `action` 以減輕頁面的重覆渲染。

> React 本身是運用 `Virtual DOM` 來渲染整個頁面的，如果渲染節點/次數過多就會導致內存占用率居高不下，`GC` 無法正常回收多余內存。因此，規避重覆渲染也可以有效減輕內存占用率。

經過這兩步優化，我們就有效的優化了 300 條 `issue` 時整體系統的運行效率，但是這依然存在一個問題：如果我只有 300 條 `issue` 不做任何分類，全部丟在`待處理`列中，並且開啟全部泳道。這時依然需要渲染整體頁面，而且幀數依然沒能達到 30 幀以上。那我們需要如何針對這一種情況做優化呢？

### 為什麽 React-beautiful-dnd 官方組件的性能會那麽好？

在沒有深入閱讀 `React-beautiful-dnd` 的官方文檔與隨想之前，我一直武斷的將總體幀數過低的原因歸因於 `React-beautiful-dnd` 本身的 設計問題，但是在我 `clone` 了 `React-beautiful-dnd` 官方庫，將他們提供的看板 Demo 卡片數量提升至 1500 後，我发現官方的 Demo 能夠很好的處理這種極端情況，而且幀數能穩定在 `60 fps`。

但這一发現明顯不符合常理，因為操作上千條 `issue` 時，本身就存在高昂的性能成本。`60 fps` 的前提是將每個整體渲染流程（js 執行 + css 重繪）的執行時間控制在 17ms 之內。如果 `beautiful-dnd` 沒有采用 `Virtualized List` 的話，根本不可能在 17 ms 之內完成近千條 `issue` 的操作。也就是說，`beautiful-dnd` 采用了另一種不同於 `Virtualized List` 的神奇方案減輕渲染負擔。

查閱官方文檔後，我发現了這篇文章：[Dragging React performance forward](https://medium.com/@alexandereardon/dragging-react-performance-forward-688b30d40a33 "Dragging React performance forward")

這篇文章詳細解釋了 `React-beautiful-dnd` 為了做到極致拖拽性能所采取的一些獨特設計方案，總體來看有以下兩個技巧：

1. 設定一系列事件，在開始拖拽時觸发，將需要的公用 `style` 放置在 `<head>` 標簽中，避免每次都去更改大量 `<Draggable>` 組件的 `style`
2. 如下圖所示，每次將卡片拖拽進一個隊列的時候，拖拽目標位置後的所有卡片都需要更改 `Position`，雖然 `CSS` 的渲染幾乎沒有成本，但是同時更改幾百個 `<Draggable>` 組件的 `style` 難免會超出 `17ms` 的操作間隔，因此在更新組件位置時，只會更新當前可視區域內的組件 `style`，可視區域外的組件樣式會等到滾動到相應位置後再去更新。

![react-beautiful-dnd演示](https://imagetemp.oss-cn-beijing.aliyuncs.com/2019-03-29-1_xio-0VMqqAzA2t45_Uzkzw.gif?x-oss-process=style/TestCompress)

這兩個小技巧也啟发了我書寫了一套簡單的高階組件，用於在組件拖拽開始時更新每個列和狀態的樣式。

第二個小技巧在 `DOM` 節點極端多的情況下依然會有明顯的卡頓，但是處理 500 條 `issue` 可以說是綽綽有余，如果卡片不覆雜的話，甚至可以處理 2500 條 `issue`。而 `Atlassian` 不采用 `Virtualized List` 的重要原因主要有兩個：

* `Virtualized List` 無法讓用戶通過 `ctrl-f` 檢索列表
* 不希望組件過多幹涉用戶自己封裝的組件，保證組件的易用性

當然，`Atlassian` 開发團隊已經將 `Virtualized List` 提上了日程，希望給用戶另一種選擇。讓我們拭目以待吧！

### 我們在使用 React-beautiful-dnd 沒有註意到的盲點

首先要說的是，`React-beautiful-dnd` 是有一個暗坑的。雖然這個暗坑的規避方式被醒目的標記在了官方文檔上，但是我們的開发明顯在當初開发的時候並沒有註意到這一點。具體來說就是這篇文檔：[Droppable](#)(https://github.com/atlassian/react-beautiful-dnd/blob/master/docs/api/droppable.md)，這篇文檔中標題為 `Recommended <Droppable /> performance optimisation` 這一部分記錄了一個潛在的影響性能的問題，就是 `<Droppable>` 組件會導致重渲染，如果沒有在下一層組件設定 `shouldComponentUpdate`，就會導致下面的所有子組件全部重渲染。解決方案自然是在 `shouldComponentUpdate` 中對比 `this.props` 與 `nextProps`，相同時不執行更新。

### 規避數組元素變動時導致的數組全渲染

與其說規避，不如說是之前對於 `React diff` 算法了解不夠深入導致的誤解。實際上來說解決方式也非常簡單，就是給每個從數組生成的 issue 設定獨一無二的 `key` 用於識別，具體原理可以看前一篇文章中的 `element-diff` 部分。

# 尾聲

新年結束後，Agile 看板服務果然不出我所料出現了嚴重的性能問題，客戶現場甚至出現了頁面完全卡死的現象。萬幸的是我在年前準備了一套針對 500 條 `issue` 的優化方案，年後又迅速的將這個數字提升至單看板 1500 條 `issue` 的上限。至此，看板的重構工作算是圓滿收工了。雖然現在看起來還是存在相當一部分的冗余代碼，但是相對於以前代碼的性能已經可以說是巨大提升了。客戶機的性能雖然比服務器好得多，但是內存占用，時間覆雜度依然是我們需要考慮的一環。否則等到系統在客戶現場奔潰就為時已晚了。

最後貼一下我這幾個月的優化成果吧：

![優化前，每拖動一次就會觸发全頁面渲染](https://imagetemp.oss-cn-beijing.aliyuncs.com/2019-03-29-%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202019-03-29%2023.59.27.png?x-oss-process=style/TestCompress)

![優化後，只觸发當前 pannel 下狀態數組的更新](https://imagetemp.oss-cn-beijing.aliyuncs.com/2019-03-29-%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202019-03-30%2000.09.04.png?x-oss-process=style/TestCompress)

> 這次重構依然是留下了一部分內存泄漏的問題，後期會專門針對 `Javascript` 內存泄漏進行研究並改進

